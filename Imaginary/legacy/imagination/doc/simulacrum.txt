I wrote this when I was rather tired, and it probably could do with
some clarifying. - radix

Simulacrum is hard.
===================

Simulacrum (imagination.simulacrum) basically defines a graph
interface. It specifies how nodes should be connected to each other
and how to search the nodes for interesting bits.

ICollector is the most important part. It specifies what nodes on the
graph need to implement in order to cooperate. The simplest
implementation of this so far is in imagination.containment.Container.

An Imagination graph is made up of two fundamental Thingies:
collectors and implementors. Collectors are things which contain,
stand in between, or otherwise control access between objects. A box
is a collector which returns its contents, a door is a collector which
returns the room behind it, and a table is a collector which returns
the things sitting atop it. Implementors, on the other hand, are those
things which someone who is looking at the graph is potentially
interested in. Everything on the graph is a potential implementor, and
the things which are returned from your searching are implementors.

collect is how one searches the graph for interesting things. It lets
you search for things based on a few things:

 * Interface. This is required -- you always search for objects that
   implement a particular interface (Like ITakeTarget; things which
   can be taken).
 * evaluator. This is an object that "evaluates" objects on the graph
   to find interesting ones. It has two common parts, so far, but 
   certain graphs might have other requirements:
   - ICollectorCriterion. This is a callable that takes a collector
     and must return True or False. If True, the collector will be
     searched for implementors.
   - IImplementorCriterion. This is a callable that takes an
     implementor and must return True or False. If True, the implementor
     will be in the final result set returned from collect().

Let's say we have a player in a room, room1. There's a closed door
leading out of the room into room2. Room2 contains a small dog.
 ___ ___
|   |   |
| @ + d |
|___|___|

This is what we want to happen:

  > look
  You see...

  Room1
  A closed door


And this is how we'll get such an effect:

  collect(actor, ILookTarget, 
          simulacrum.makeEvaluator(lambda o: IPhysical(o).lightPermeable, 
                                   None))

This is how we search for things that the player can look at. First,
since it's the player who's doing the looking, we pass him as the
first argument to collect -- the "start" argument -- to specify that
that's where the search should begin. The interface that we care about
comes next: ILookTarget. We only care about things which can be looked
at (so invisible ghosts or gusts of wind won't be returned).

The third argument is a doozy. simulacrum.makeEvaluator is a utility
function for creating an evaluator object the likes of which I
mentioned above. It takes two arguments, generally functions which
accept a single argument. The first will become the
ICollectorCriterion and the second the IImplementorCriterion.
makeEvaluator simply creates a new Componentized object and sets these
functions as the implementors for those interfaces on it. The search
process will call these functions on potential collectors or
implementors to see whether you care about them.

Our collector implementor is

lambda o: IPhysical(o).lightPermeable

In our virtual world, vaguely similar to the real world, eye sight
works with light. To be able to see beyond or inside or through
things, they must allow light to pass. So all collectors that we
traverse in our search must implement the IPhysical interface and have
their lightPermeable attribute set to something true. 

The result of this collection is only the room and the door. But let's
make things more interesting!

> open door
You open the door.
> look
You see...

Room1
An open door
Room2
A small dog

The only thing that requires this to work is that our door
implementation must set IPhysical(self).lightPermeable to True
whenever it is open. The collection will then continue to the room
beyond the door and from there to the small dog.



CRAZY CASES
===========

Here's a couple things that ought to be discussed:

 - A shimmering portal that obscures, but doesn't make
 entirely invisible, things on the other side of it. I think the best
 way to do it is to implement ICollector.find() on your Portal so that
 it wraps ILookTargets behind it in something that makes their
 description less precise. e.g., if the implementor is a human that
 the looker knows as David, replace "You see David" with "You see a
 humanoid". etc.

 Need to think about how to implement the following two more.

 - A container that has a hole smaller than your hand, but large
 enough for a pixie's. Something enticing is in the box, waiting to be
 taken.

 - A container that has a hole large enough for your hand, with an
 enticing object inside, but the object is too large to fit through
 the hole.
