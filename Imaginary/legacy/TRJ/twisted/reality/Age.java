package twisted.reality;

import java.awt.Frame;
import java.awt.FileDialog;

import java.util.Hashtable;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.Date;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.io.FileNotFoundException;
import java.io.LineNumberReader;
import java.io.StreamTokenizer;
import java.io.PrintWriter;
import java.io.StringReader;
import java.io.BufferedWriter;

import twisted.util.LinkedList;
import twisted.util.LogListener;
import twisted.util.ClassGrabber;
import twisted.util.SetupWrapper;

/**
 * The Universe class.  Named in homage to the Miller brothers'
 * popular graphical computer adventure game, Myst.
 * 
 * @version 1.2.2, 30 Dec 1999
 * @author Glyph Lefkowitz
 */

public class Age
{
	/**
	 * This represents the current version of the Reality Pump.
	 */
	public static final String version = "1.2.2";
	
	public static final long OneEventMillis   = 2712;
	public static final long OneDayMillis     = 86400000;
	
	public static final long OneMinuteMillis  = 6000;
	public static final long OneHourMillis    = OneMinuteMillis * 60;
	public static final long TenMinutesMillis = OneMinuteMillis * 10;

	
	static final int EXTREMELY_VERBOSE = 4;
	static final int VERY_VERBOSE = 3;
	static final int VERBOSE = 2;
	static final int BRIEF = 1;
	static final int VERY_BRIEF = 0;
	
	static int verbosity = VERY_BRIEF;
	
	static Hashtable strings = new Hashtable();
	static LinkedList logListeners = new LinkedList();
	
	/**
	 * This function is available due to the following bug in JDK
	 * 1.1.7v1a on Linux.  In theory I should be able to use
	 * String.intern(), but if you use too many of those you get the
	 * JVM to core with some interesting output:
	 
	 *** panic: 16-bit string hash table overflow
	 SIGABRT   6*   abort (generated by abort(3) routine)
	 stackbase=0xbffff780, stackpointer=0xbffff680
	 
	 Full thread dump:
	 "Finalizer thread" (TID:0x41799258, sys_thread_t:0x459e5e0c, state:R)
	 prio=1
	 "Idle thread" (TID:0x417992a0, sys_thread_t:0x459c4e0c, state:R)
	 prio=0
	 "Clock" (TID:0x41799088, sys_thread_t:0x459a3e0c, state:CW) prio=12
	 "main" (TID:0x417990b0, sys_thread_t:0x818ccb0, state:R) prio=5
	 *current thread*
	 twisted.reality.Nameable.name(Nameable.java:7)
	 twisted.reality.Thing.name(Thing.java:714)
	 twisted.reality.ThingFactory.handleIt(ThingFactory.java:49)
	 twisted.reality.ThingFactory.generate(ThingFactory.java:35)
	 twisted.reality.Age.loadFile(Age.java:134)
	 twisted.reality.Age.LoadAge(Age.java:87)
	 twisted.reality.Pump.main(Pump.java:39)
	 Monitor Cache Dump:
	 Registered Monitor Dump:
	 [bunch of unowned thread monitors]
	 String intern lock: owner "main" (0x818ccb0, 1 entry)
	 [a bunch more]
	 Monitor registry: owner "main" (0x818ccb0, 1 entry)
	 Thread Alarm Q:
	*/
	
	static String intern(String s)
	{
		if (s==null) return null;
		if (!strings.containsKey(s))
		{
			strings.put(s,s);
		}
		return (String)strings.get(s);
	}
	
	synchronized void doEventStuff()
	{
		if(del!=null) 
			del = del.executeEvents(System.currentTimeMillis());
	}
	
	synchronized void haltTheUniverse()
	{
		haltTheUniverse(true);
	}

	synchronized void haltTheUniverse(boolean b)
	{
		currthrd.stop();
		currthrd=null;
		
		// STAGE 1
		
		Enumeration x = players();
		while(x.hasMoreElements())
		{
			Player p = (Player)  x.nextElement();
			p.setUI(null);
		}
		
		if(del!=null) 
			del = del.executeEvents(Long.MAX_VALUE);
		
		UNIVERSE.allHandleRealEvent(new RealEvent("shutdown",null,null));		
		persistToFile("shutdown."+System.currentTimeMillis());

		if(b) System.exit(0);
	}
	
	/**
	 * Add a Log Listener to the system log.
	 */
	
	public final static void addLogListener(LogListener l)
	{
		logListeners.addElement(l);
	}
	

	/**
	 * Remove a Log Listener from the system log.
	 */
	public final static void removeLogListener(LogListener l)
	{
		logListeners.remove(l);
	}
	/**
	 * Logs the given object to the standard output, which is usually
	 * redirected by the runner of this program to a logfile.  Useful
	 * for debugging information, or things which Gods should be able
	 * to watch (like scanning for possible cheating, or waiting for a
	 * certain puzzle to be solved).
	 *
	 * @param 
	 */
	
	final public static void log(Object o, int debug)
	{
		String s = String.valueOf(o);
		if(verbosity>=debug)
		{
			tempDate.setTime(System.currentTimeMillis());
			System.out.println(tempDate.toString() + " :: " + s);
		}
		if(logListeners!=null) synchronized(logListeners)
		{
			if(recurse) return;
			recurse = true;
			Enumeration e = logListeners.elements();
			while(e.hasMoreElements())
			{
				LogListener l = (LogListener) e.nextElement();
				try
				{
					l.log(debug, tempDate, s);
				} catch (Throwable t)
				{
					logListeners.remove(l);
					System.out.println("Fatal error occured in a LogListener. Removed." + t);
				}
			}
			recurse = false;
		}
	}
	private static boolean recurse = false;

	static Date tempDate = new Date();
	
	/**
	 * Write this object out to the log at highest priority (it will
	 * always be written).
	 */
	public final static void log(Object o)
	{
		log(o, VERY_BRIEF);
	}

	/**
	 * This method loads the universe in from a file.
	 * 
	 * @param fnm The name of the file to load from.  
	 */
	
	final static void LoadAge(String fnm)
	{
		if(UNIVERSE == null)
		{
			UNIVERSE = new Age();
			UNIVERSE.loadFile(fnm);
			
			Thread tstart = UNIVERSE.currthrd=new Thread(new AgeX(UNIVERSE));
			UNIVERSE.allHandleRealEvent(new RealEvent("startup",null,null));
			tstart.start();
		}
	}
	Thread currthrd;

	/**
	 * Utility function that returns how much memory the Pump is currently
	 * using.  (This is necessarily an accurate value, due to the way java
	 * allocates memory).
	 */

	public static long usedMem( )
	{
		Runtime r = Runtime.getRuntime();
		return r.totalMemory() - r.freeMemory();
	}
	
	/**
	 * Gets the actual Thing data out of a file.
	 * 
	 * @param fnm The name of the file to load from.
	 */
	
	final void loadFile(String fnm)
	{
		PERSISTS=new Hashtable();
		ThingFactory tf;
		//cl_int=new ClassGrabber();
		int TT_EOF = -1;
		int TT_WORD = -3;
		if(fnm==null || fnm.equals("") )
		{
			Frame x = new Frame("Load File");
			FileDialog y = new FileDialog(x,"Please Select a File:");
			y.show();
			z = new File(y.getDirectory()+y.getFile());
			x.dispose(); y.dispose();
		}
		else
		{
			z = new File(fnm);
		}
		try
		{
			Age.log("Requested file: "+z.getName());

			FileInputStream zb = new FileInputStream(z);
			LineNumberReader thebr;
			try
			{
				thebr = new LineNumberReader(new InputStreamReader(zb, "UTF8"));
			} catch (UnsupportedEncodingException e) {
				System.out.println("Your Java VM doesn't support the UTF8 encoding.");
				System.out.println("This encoding is required to read and write mapfiles. Aborting.");
				return;
			}
			try
			{
				long l = System.currentTimeMillis();
				StreamTokenizer zq = new StreamTokenizer( thebr );
				SetupWrapper sww=new SetupWrapper();
				
				int nt;
				
				long maxMem = Long.MIN_VALUE,minMem = Long.MAX_VALUE, lastMem = 0;
				long firstMem = lastMem = usedMem();
				Age.log("Memory use before loading: " + firstMem);

				while((nt=zq.nextToken())==TT_WORD)
				{
					tf=FactoryFactory.getFactory(zq.sval,zq,sww);
					tf.generate();
/*					long curMem = usedMem();
					long thisMem = curMem - lastMem;
					if (thisMem < minMem) minMem = thisMem;
					if (thisMem > maxMem) maxMem = thisMem;
					lastMem = curMem;
*/
				}
				lastMem=usedMem();
				Age.log("Memory use after loading " + lastMem + " diff: " + (lastMem - firstMem));
/*				Age.log("Max Mem/Thing: " + maxMem + "  Min Mem/Thing: " + minMem);
				Age.log("Avg Mem/Thing: " + ((double)lastMem - firstMem) / Age.theUniverse().STUFF.size());
*/				
				if(nt!=TT_EOF)
				{
					throw new ExpectedException("a word");
				}
				
				sww.wrapper();
				l=System.currentTimeMillis()-l;
				Age.log ("Init time: " + (l/1000) + " seconds");
				Age.log ("Things: "+Age.theUniverse().STUFF.size());
				
				Age.log("Memory use after finishing " + usedMem() + " diff: " + (usedMem() - lastMem));
			}
			catch (java.io.IOException e)
			{
				log(e);
				log("Couldn't get file properly.");
			}
			catch (RPException ee)
			{
				log("Error in file, at line: "+ thebr.getLineNumber());
				log(ee);
			}
		}
		catch (FileNotFoundException fnfe)
		{
			log("no such map");
		}
		//cl_int = null;
		PERSISTS = null;
	}
	
	DelayedEventList del;
	
	void installDelayedEvent(RealEvent e, int a, Thing t, boolean it)
	{
		if(currthrd==null) return;
		
		DelayedEventList d = new DelayedEventList(e,a,t, it);
		
		if(del==null)
		{
			del=d;
		}
		else
		{
			del.insertEvent(d);
		}
	}
	
	/**
	 * This outputs the current worldstate on the standard output.
	 * This can be useful for debugging sometimes, but for far little
	 * else.
	 */
	final void persistToSystem()
	{
		Enumeration enum = STUFF.elements();
		
		while(enum.hasMoreElements())
		{
			log( ((Thing) enum.nextElement()).persistance() );
		}
	}
	
	Dictionary PERSISTS;
	
	/**
	 * Saves the current worldstate to the named file. (Appends a .por
	 * extension to denote filetype.)
	 */
	
	public final synchronized void persistToFile(String s)
	{
		persistToFile(s,STUFF.elements());
	}

	/**
	 * Saves a portion of the current worldstate to the named
	 * file. (Appends a .por extension to denote filetype.
	 * 
	 * @param filename The file-name, minus '.por', of the map being
	 * generated.
	 *
	 * @param things An enumeration of all of the things to be
	 * persisted.  */

	public synchronized void persistToFile(String filename, Enumeration things)
	{
		try
		{
			/* Make a place to store the already-persisted state of persistables */
			PERSISTS=new Hashtable();
			File zz = new File(/*System.getProperties().getProperty("user.dir"),*/
							   filename+".por");
			FileOutputStream fos = new FileOutputStream(zz);
			try
			{
				PrintWriter prnt = new PrintWriter(new BufferedWriter(new OutputStreamWriter(fos, "UTF8")));
				
				while(things.hasMoreElements())
				{
					Object tt = things.nextElement();
					if (tt instanceof ThingIdentifier)
						prnt.println( tt );
					else if (tt instanceof Thing)
						prnt.println( ((Thing)tt).ref );
				}
				prnt.flush();
				fos.close();
				PERSISTS=null;
				/* OK, now all the persistables should be recognized as unpersisted */
				System.gc();
				/* And we probably made a big ol' mess doing that */
			} catch (UnsupportedEncodingException e) {
				System.out.println("Your Java VM doesn't support the UTF8 encoding.");
				System.out.println("This encoding is required to read and write mapfiles. Aborting.");
				return;
			}
		}
		catch(java.io.IOException e)
		{
			log("Error in persisting to file.");
		}
	}
	
	/**
	 * Searches for a Thing by its unique name.
	 * 
	 * NOTE: this name does
	 * not use synonyms, which is what most players search by.  For
	 * instance, 'sword' is far too common a name to be unique.  A sword
	 * which is a common broadsword might have a name like 'sword (122)'
	 * and won't be accessed via this search by 'sword'.
	 * 
	 * @see twisted.reality.Nameable.NAME()
	 */
	
	public final Thing findThing(String theString)
	{
		if(theString == null) return null;
		ThingIdentifier y = ( (ThingIdentifier) STUFF.get(theString.toLowerCase()) );
		return ( (y == null) ? null : y.sThing() );
	}
	
	/**
	 * Returns a reference to an object, searched for by its unique
	 * name OR a new reference, which will be "filled in" when an
	 * object with that name is created. (This is useful for creating
	 * persistant data types.)
	 *
	 * @see twisted.reality.Persistable
	 */
	
	public final ThingIdentifier findIdentifier(String theString)
	{
		if(theString == null)
			return null;
		ThingIdentifier y = ( (ThingIdentifier) STUFF.get(theString.toLowerCase()) );
		if(y==null)
		{
			STUFF.put(theString.toLowerCase(),y=new ThingIdentifier());
		}
		return y;
	}
	
	/**
	 * Adds a Thing to the global synonym list.
	 */
	
	final void addSyn(String s, Thing t)
	{
		STUFF.put( s,t.ref );
	}
	
	/**
	 * Adds a player to the player search list.
	 */
	
	final void connect(Player who, RealityUI ui)
	{
		// log("Connecting " + who.NAME() + "...");
		if(who.getUI() != null)
		{
			who.getUI().errorMessage("You have been disconnected because you logged in from another computer");
			who.setUI(ui);
		}
		else
		{
			who.setUI(ui);
			PLAYERS.put(who,who);
			who.handleEvent(login);
		}
	}
	final static RealEvent login = new RealEvent("login",null,null);

	/**
	 * Disconnects the player from the game.
	 */

	public final void disconnect(Player who)
	{
		PLAYERS.remove(who);
		who.handleEvent(logout);
		who.setUI(null);
	}
	final static RealEvent logout = new RealEvent("logout",null,null);

	/**
	 * Returns a list of players currently online.
	 * Note: this is not a full list of users in the game,
	 * only those who are currently logged in.
	 */
	
	public final Enumeration players( )
	{
		return PLAYERS.elements();
	}
	
	/**
	 * Adds a Thing to the global synonym list.
	 */
	
	final void addSyn(Thing t)
	{
		addSyn(t.NAME().toLowerCase(),t);
	}
	
	/**
	 * Removes a Thing from the global search list.
	 * 
	 * Note: if you place an object in 'null' and then remove it from
	 * the global list, the object is eventually garbage-collected --
	 * this is what Thing.dispose() does.
	 */
	
	final void removeSyn(Thing t)
	{
		Object o = STUFF.get(t.NAME().toLowerCase());
		if(o!=null)
		{
			ThingIdentifier i = (ThingIdentifier) o;
			STUFF.remove(t.NAME().toLowerCase());
		}
	}
	
	/**
	 * Creates a new Age.
	 */
	Age()
	{
		
		STUFF = new Hashtable();
		PLAYERS = new Hashtable();
		CONFLICTS = new Hashtable();
		classList = new Hashtable();
		cl_int = new ClassGrabber();
	}
	
	/**
	 * Returns the next available number for a given Thing name.  IE,
	 * if there are 30 objects called sword(n) where n is a number
	 * from 1 - 30, this will return 31.  Note - please don't start
	 * naming things stuff like "sword(3024)" right away: use your
	 * imagination and put some adjectives in there.  In fact, don't
	 * use funny chars in Thing names in general, it makes 'em tough
	 * to type.
	 * 
	 * @param s The string to look up.
	 */
	
	int conflictNum(String s)
	{
		Integer i;
		Object o = CONFLICTS.get(s);
		
		if(o==null)
		{
			i = new Integer(1);
			CONFLICTS.put(s,i);
			return i.intValue();
		}
		else
		{
			if(o instanceof Integer)
			{
				i = (Integer)o;
				i = new Integer(i.intValue()+1);
				CONFLICTS.put(s,i);
				
				return i.intValue();
			}
			else
			{
				log("Reality Runtime error - ConflictNum caught a non-integer");
			}
		}
		
		throw new NullPointerException();
	}
	
	/**
	 * Sends an event to every object in the game
	 * simultaneously... don't overuse this! It's intended for
	 * cataclysmic events, god-type gamewide announcements, and stuff
	 * like that.
	 * 
	 * @param evt The event to handle.
	 */
	
	public void allHandleRealEvent(RealEvent evt)
	{
		Enumeration e = STUFF.elements();
		while(e.hasMoreElements())
		{
			try
			{
				((ThingIdentifier) e.nextElement()).sThing().handleEvent(evt);
			}
			catch(Exception xe)
			{
				Age.log("Exception in thing handler, allHandleRealEvent");
				xe.printStackTrace();
			}
			catch(Error oe)
			{
				Age.log("Error in thing handler, allHandleRealEvent");
				oe.printStackTrace();
			}
		}
	}
	
	
	private Hashtable classList;
	
	/**
	 * Loads a class into its own comfortable little universe.
	 */
	
	Object loadClass(String s) throws ClassNotFoundException
	{
		Object o;
		try
		{
			Class x = cl().loadClass(s);
			o=x.newInstance();
			classList.put(s,o);
			return o;
		}
		catch(ClassNotFoundException c)
		{
			throw new ClassNotFoundException("Class \"" +s+ "\" not found.");
		}
		catch(InstantiationException ie)
		{
			throw new ClassNotFoundException("Could not instantiate \""+s + "\".");
		}
		catch(IllegalAccessException iae)
		{
			throw new ClassNotFoundException("Class constructor of \"" +s+ "\" is not public.");
		}
	}

	synchronized Object dynLoadClass(String s) throws ClassNotFoundException
	{
		if(s==null) throw new ClassNotFoundException("Null class specified.");
		Object o = classList.get(s);
		if(o!=null) return o;
		return loadClass(s);
	}
	
	// utility functions
	
	DynamicProperty dynLoadProp(String s) throws ClassNotFoundException
	{
		try {
			return (DynamicProperty)dynLoadClass(s);
		} catch(ClassCastException cc) {
			throw new ClassNotFoundException("Class \"" +s+ "\" was not a DynamicProperty.");
		}
	}
	
	RealEventHandler dynLoadEvent(String s) throws ClassNotFoundException
	{
		try {
			return (RealEventHandler)dynLoadClass(s);
		} catch(ClassCastException cc) {
			throw new ClassNotFoundException("Class \"" +s+ "\" was not an RealEventHandler.");
		}
	}
	
	Verb dynLoadVerb(String s) throws ClassNotFoundException
	{
		try {
			return (Verb)dynLoadClass(s);
		} catch(ClassCastException cc) {
			throw new ClassNotFoundException("Class \"" +s+ "\" was not a Verb.");
		}
	}

	DynamicProperty loadProp(String s) throws ClassNotFoundException
	{
		try {
			return (DynamicProperty)loadClass(s);
		} catch(ClassCastException cc) {
			throw new ClassNotFoundException("Class \"" +s+ "\" was not a DynamicProperty.");
		}
	}
	
	RealEventHandler loadEvent(String s) throws ClassNotFoundException
	{
		try {
			return (RealEventHandler)loadClass(s);
		} catch(ClassCastException cc) {
			throw new ClassNotFoundException("Class \"" +s+ "\" was not a RealEventHandler.");
		}
	}
	
	Verb loadVerb(String s) throws ClassNotFoundException
	{
		try {
			return (Verb)loadClass(s);
		} catch(ClassCastException cc) {
			throw new ClassNotFoundException("Class \"" +s+ "\" was not a Verb.");
		}
	}
	
	/**
	 * Returns the currently active universe. (See also
	 * java.lang.Runtime.getRuntime())
	 */
	
	final public static Age theUniverse()
	{
		return UNIVERSE;
	}
	
	static Age UNIVERSE;
	
	Dictionary STUFF;
	Dictionary PLAYERS;
	
	Dictionary CONFLICTS;
	
	ClassLoader cl()
	{
		if (cl_int != null)
		{
			return cl_int;
		}
		else
		{
			return cl_int=new ClassGrabber();
		}
	}
	
	ClassLoader cl_int;
	
	/**
	 * Clears all the code caches.  Use this to make a verb, event handler, 
	 * dynamic property, or other dynamically loaded code that you have modified
	 * take effect. 
	 */
	public void reloadEverything()
	{
		cl_int=new ClassGrabber();
		classList.clear();
	}
	
	File z;
	Room theSpot;
	
	/**
	 * This loads a Thing (Location, Room, or group of Things) into
	 * this Age.  This is basically a hook used for
	 * twisted.reality.author.SketchProcessor.
	 */
	
	public void loadMapString(String s)
		throws java.io.IOException, RPException
	{
		StringReader zb = new StringReader(s);
		StreamTokenizer zq = new StreamTokenizer( zb );
		SetupWrapper sww=new SetupWrapper();
		int TT_EOF = -1;
		int TT_WORD = -3;
		ThingFactory tf;
		
		int nt;
		
		while((nt=zq.nextToken())==TT_WORD)
		{
			tf=FactoryFactory.getFactory(zq.sval,zq,sww);
			tf.generate();
		}
		if(nt!=TT_EOF)
		{
			throw new ExpectedException("a word");
		}
		sww.wrapper();
	}
}
