#!/usr/bin/env python

"""joopstub file.java

This generates a stub file for Gloop named _file.java.
"""
		
from twisted.tokenizer import *

primitives={'int':'new Integer(%s)'}
primitive_returns={'int':'return ((Integer)%s).intValue();',
				   'void':'%s;'}
primitive_arguments={'int':'new Integer(%s)'}

known=['String','Vector']
mandatory='Exception'

class JavaMethod:

	def __init__(self):
		self.args=[]
		self.exceptions=[]

	def add_arg(self,typ,name):
		self.args.append((typ,name))

	def add_exception(self,exc):
		self.exceptions.append(exc)

	def format_exceptions(self):
		x=''
		for i in self.exceptions:
			x=x+"%s,"%i
		return x[:-1]

	def format_args(self):
		x=''
		for typ,nam in self.args:
			x=x+"%s %s,"%(typ,nam)
		return x[:-1]

	def format_argparse(self):
		x=''
		for typ,nam in self.args:
			if primitive_arguments.has_key(typ):
				x=x+"%s,"%primitive_arguments[typ]%nam
			else:
				x=x+"%s,"%nam
		return 'Object[] args = {%s};'%x[:-1]

	def format_globget(self):
		return 'Glob _%s = (Glob) wrapped.get("%s");' % (self.name,self.name)

	def format_return(self):
		if primitive_returns.has_key(self.return_type):
			return primitive_returns[self.return_type] % '_%s.call(args)' % self.name
		if self.return_type in known:
			return 'return (%s) _%s.call(args);' % (self.return_type,self.name)
		return  'return new _%s((Glob)_%s.call(args));' % (self.return_type,self.name)
	
	def format_decl(self):
		return "public %s %s (%s) throws %s"%(self.return_type,self.name,self.format_args(),self.format_exceptions())
	def format(self):
		return "\t%s\n\t{\n\t\t%s\n\t\t%s\n\t\t%s\n\t}" % (self.format_decl(),
													   self.format_argparse(),
													   self.format_globget(),
													   self.format_return())
class JavaInterface:
	def ignore(self):
		pass

	def parse_package(self):
		token=self.tok.next()
		tstr=''
		while token.value != ';':
			tstr=tstr+token.value
			token=self.tok.next()
		self.package=tstr
		
	def parse_import(self):
		token=self.tok.next()
		tstr=''
		while token.value != ';':
			tstr=tstr+token.value
			token=self.tok.next()
		self.imports.append(tstr)

	def parse_method(self,return_type):
		jm=JavaMethod()
		jm.return_type=return_type
		if jm.return_type == 'public':
			jm.return_type=self.tok.next().value
		jm.name=self.tok.next().value

		curtok=self.tok.next().value
		while curtok!=')':
			typ=self.tok.next().value
			if typ == ')': break
			nam=self.tok.next().value
			jm.add_arg(typ,nam)
			curtok=self.tok.next().value
		curtok=self.tok.next().value
		if curtok != 'throws':
			raise 'need to throw stuff'
		while curtok != ';':
			curtok=self.tok.next().value
			jm.add_exception(curtok)
			curtok=self.tok.next().value
		self.methods.append(jm)
	
	def parse_interface(self):
		self.name=self.tok.next().value
		brc=self.tok.next().value
		if brc == 'extends':
			self.superclass=self.tok.next().value
		rval=self.tok.next().value
		while rval != '}':
			self.parse_method(rval)
			rval=self.tok.next().value
		
	def __init__(self,t):
		self.tok=t
		self.methods=[]
		self.superclass=None
		self.imports=[]
		fdict={'package':self.parse_package,
			   'public':self.ignore,
			   'interface':self.parse_interface,
			   'import':self.parse_import}
		nt=self.tok.next().value
		while nt:
			fdict[nt]()
			nt=self.tok.next().value
	def format(self):
		rv = 'package %s;\n'%self.package
		for i in self.imports:
			rv=rv+ "import %s;\n"%i
		rv=rv+ """\
public class _%s implements %s
{
	public Glob wrapped;
	public _%s (Glob glob)
	{
		wrapped=glob;
	}
""" % (self.name,self.name,self.name)
		for i in self.methods:
			rv=rv+i.format()+"\n"
		rv=rv+"\n}"
		return rv
		
if __name__=='__main__':
	import sys
	if len(sys.argv) != 2:
		print __doc__

	t=Tokenizer(open(sys.argv[1]),ignored=(INDENT, DEDENT))
	t.stripcppcomments()
	ji=JavaInterface(t)
	open("_"+sys.argv[1],'wb').write(ji.format())
