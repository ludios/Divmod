<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="XEmacs (X11; I; Linux 2.0.36 i686)">
</HEAD>
<body bgcolor=white text=black>

<CENTER><FONT SIZE=+4>Verb Index</FONT></CENTER>
<P><BR><P><U><FONT SIZE=+1>Twisted Reality Verbs:</FONT></U>
<BLOCKQUOTE>
[<A HREF="#adduser">adduser</A>]
[<A HREF="#allow">allow</A>]
[<A HREF="#banish">banish</A>]
[<A HREF="#barricade">barricade</A>]
[<A HREF="#boolean">boolean</A>] 
[<A HREF="#broad">broad/debroad</A>] 
[<A HREF="#compile">compile</A>]
[<A HREF="#cvs">cvs</A>]
[<A HREF="#describe">describe</A>]
[<A HREF="#dig">dig</A>]
[<A HREF="#disable">disable</A>]
[<A HREF="#disallow">disallow</A>]
[<A HREF="#draw">draw</A>] 
[<A HREF="#erase">erase</A>]
[<A HREF="#enable">enable</A>]
[<A HREF="#extend">extend</A>]
[<A HREF="#float">float</A>]
[<A HREF="#gate">gate</A>]
[<A HREF="#grab">grab</A>]
[<A HREF="#handle">handle</A>]
[<A HREF="#he">he/she</A>]
[<A HREF="#int">int</A>]
[<A HREF="#killprop">killprop</A>]
[<A HREF="#locate">locate</A>]
[<A HREF="#mood">mood/unmood</A>]
[<A HREF="#nail">nail</A>]
[<A HREF="#obstruct">obstruct</A>]
[<A HREF="#op">op/deop</A>]
[<A HREF="#passwd">passwd</A>]
[<A HREF="#persist">persist</A>]
[<A HREF="#property">property</A>]
[<A HREF="#reference">reference</A>]
[<A HREF="#refrump">refrump</A>]
[<A HREF="#scrutinize">scrutinize</A>]
[<A HREF="#sketch">sketch</A>]
[<A HREF="#string">string</A>]
[<A HREF="#theme">theme</A>]
[<A HREF="#thing">thing</A>]
[<A HREF="#toss">toss</A>]
[<A HREF="#tunnel">tunnel</A>]
[<A HREF="#undescript">undescript</A>]
[<A HREF="#vis">vis/devis</A>]  
[<A HREF="#yank">yank</A>]
</BLOCKQUOTE>

<P><BR><P><U><FONT SIZE=+1>Divunal Verbs:</FONT></U>
<BLOCKQUOTE>
[<A HREF="divunalverbs.html#discover">discover</A>]
[<A HREF="divunalverbs.html#listen">listen/unlisten</A>]
[<A HREF="divunalverbs.html#shadowstep">shadowstep</A>]
[<A HREF="divunalverbs.html#twin">twin/untwin</A>]
[<A HREF="divunalverbs.html#visit">visit</A>]
</BLOCKQUOTE>

<P><BR><A NAME="argdefs"><U><FONT SIZE=+1>Verb Arguements and Their
Meanings:</FONT></U>
<BR>
<BLOCKQUOTE>[new-*]

<BLOCKQUOTE>The name of something which will be a thing but doesn't
currently exist.</BLOCKQUOTE>

[local-*]

<BLOCKQUOTE>The name of an object which already exists and is in the
author's current scope (i.e. in the room with them).</BLOCKQUOTE>

[global-*]

<BLOCKQUOTE>The name of something which already exists somewhere else in
the game. * can be a thing (which means any twisted.reality.Thing), location
(which means location, room, or player), player, or room.</BLOCKQUOTE>

{ to * }

<BLOCKQUOTE>An arguement where an indirect object specified with the
preposition 'to' is optional.</BLOCKQUOTE>

[X-classname]

<BLOCKQUOTE>The representation of a java classname (a valid
twisted.reality.yourpath.YourVerb).</BLOCKQUOTE>

[verb-name]

<BLOCKQUOTE>The gametime representation of a verb (i.e.: "take" or
"drop").</BLOCKQUOTE>

[local-portal]

<BLOCKQUOTE>The name of an exit from the current room.</BLOCKQUOTE>

[new-portal]

<BLOCKQUOTE>The name of an exit which does *not* currently exist in the
room.</BLOCKQUOTE>

[string]

<BLOCKQUOTE>an arbitrary string.</BLOCKQUOTE>

[a : b]

<BLOCKQUOTE>

<p>In the following definitions, b is the arbitrary name assigned
to the argument type a.</p>

<p><TT>For example, [new-thing : <I>thing</I>] means that the verb in
question accepts a single arguement of type [new-thing] which will be
referred to as <I>thing</I> in the definition.</TT></p>

</BLOCKQUOTE>

</BLOCKQUOTE>

<P><BR><U><FONT SIZE=+1>TR Verb Definitions:</FONT></U></p>

<p><A NAME="draw"><B>draw [new-thing : <I>thing</I>]</B></p>

<BLOCKQUOTE>

<p>Creates <I>thing</I>, a new, blank, generic thing. Note that
<I>thing</I> must have a globally unique name.</p>

<P><TT>Example: If you are building a new door for the basement of
your castle, you should call it something like "castle basement door";
the name should be both distinctive from other objects of its type,
and easy to remember in context.</TT></p>

</BLOCKQUOTE>

<A NAME="erase"><B>erase [local-thing : <I>thing</I>]</B>

<BLOCKQUOTE>

<p>Erases <I>thing</I>, permanently removing it from the map.
You should use this verb carefully, and know exactly what it is you are
erasing before you erase it.</p>

<P><TT>Example: If I want to get rid of my "castle basement door"
object, I would type "erase castle basement door". Since erase takes a
local-thing as an arguement, I can only erase things in my immediate
vicinity. However, it's still good policy to refer to things by their
full global name, to prevent myself from erasing the wrong thing.  If
I had typed "erase door", and there was only one door in the room, and
it wasn't the one I wanted to erase, that would be bad.</TT>

</BLOCKQUOTE>

<A NAME="describe"><B>describe [local-thing : <I>thing</I>]</B>

<BLOCKQUOTE>

<p>Sets the description of <I>thing</I>. The description is, of
course, the text displayed when you see when you look at something, be
it an object, player, or room.
</p>
<TT><P>Example: To add a description to my "ornate silver
key" object, I would type "describe ornate silver key". This would open
a small window where I could enter it's description. After I closed the
window, the description would be attached to the object, and anyone who
looked at the object ("look ornate silver key") would see the description.&nbsp;
The only exception to this functionality is in room descriptions, which
are displayed in the room description windows of anyone who enters the
room or types "look" while inside it.</p></TT>

</BLOCKQUOTE>

<A NAME="mood">
<B>mood [local-thing : <I>thing</I>] to [string : <i>mood</i>]</B>
<B>unmood [local-thing : <I>thing</I>]</B>
<BLOCKQUOTE>

<p>Sets the mood of <I>thing</I>, or removes the mood,
respectively. The mood will be inserted into the listing of
<i>thing</i> in the room's contents, e.g. "<i>thing</i> is here,
<i>mood</i>".
</p><TT>
<P>This is pretty straightforward... Just remember that this is mostly a diagnostic tool... Moods should really be controlled by other verbs/events so that they will stay correct. (If I put a mood of "glued to the ceiling" on Bob, it won't go away until I remove it... And it will look dumb for Bob to be glued to the ceiling wherever he goes and whatever he happens to be doing.) Also, be sure to actually use "unmood" to remove the mood, rather than just setting it to an empty string... You don't want to see "Bob is here, ." all over the place, do you?
</P>
<P>For example: If I wanted my brass gyroscope to appear to be floating in the air, I could type
<BLOCKQUOTE></TT>mood gyroscope to "floating in the air"<TT></BLOCKQUOTE>
And it would appear in the object listing as "a brass gyroscope is here, floating in the air." Note that I put the mood in quotes in the example... Why? Well, it's got a preposition, you see, and TR likes to assume that prepositions indicate Indirect Objects, and thus, additional commands, rather than a string. Putting Strings in "quotes" is always a good thing to do.
</TT></p>

</BLOCKQUOTE>

<A NAME="enable"><B>enable [local-thing : <I>thing</I>] to
[Verb-classname : <I>verb</I>]</B>


<BLOCKQUOTE>

Allows players to use <I>thing</I> in order to perform <I>verb.</I>
Note that <I>thing</I> could be a player. Compare with <A
HREF="allow">allow</A>.  <P><TT>Example: If I wanted to create a can
opener that players could use to open cans, I would <A
HREF="#draw">draw</A> the can opener, create a special CanOpen verb
and then type "enable&nbsp; can opener to
divunal.author.common.CanOpen". Assuming my CanOpen verb is written
correctly, this would allow players to perform actions like "open tuna
can with can opener". Enable can also be used to enable verbs to
players, but remember that other nearby players will be able to use
the verb as well.&nbsp; This is good for social verbs that are used on
players (like smile, kick, etc.)  but bad for skills and
powers... unless the player is <I>supposed</I> to be a walking
appliance.</TT>

</BLOCKQUOTE>

<A NAME="disable"><B>disable [local-thing : <I>thing</I>] from [verb-name
: <I>verb</I>]</B>

<BLOCKQUOTE>

<p>Removes <I>thing</I>'s ability to be used to perform
<I>verb</I>. Essentially the opposite of the <A
HREF="#enable">enable</A>.</p>

<P><TT>Example: To make my can opener no longer capable of being used
to open cans, I would type "disable can open from CanOpen".</TT></p>

</BLOCKQUOTE>

<A NAME="extend"><B>extend [local-thing : <I>thing</I>] from [global-thing
: <I>class</I>]</B>

<BLOCKQUOTE>

<p>Sets the superclass of <I>thing</I> to <I>class</I>, allowing<I>
thing</I> to inherit <I>class</I>'s properties. Usually, class things
will have a "class_" prefix on their names, such as <I>class_human</I>
and <I>class_player</I>.</p>

<P><TT>Example: If I wanted to make a new type of thing, which there
were several subspecies of, I would make a prototype thing
first.&nbsp; If I was making flowers, I would <A HREF="#draw">draw</A>
a class_flower first, and give it all the standard attributes I wanted
a flower to have (removable petals, an <A HREF="#enable">enabled</A>
smell verb, etc.) and place it in the class room for safe
keeping. (Giving it an obvious class name and putting it somewhere
safe helps to prevent people from messing with it). Finally, I could
<A HREF="#draw">draw</A> a new thing, say, a "long stemmed red rose",
and type "extend long stemmed red rose from class_flower", and the
rose would inherit all of the properties of the flower class, saving
me a lot of work in creating new flowers.</TT></p>

</BLOCKQUOTE>

<A NAME="adduser"><B>adduser [new-player : <I>player</I>]</B>

<BLOCKQUOTE>

This creates a new, blank player character template named <I>player</I>.
Player characters must be created with adduser in order to have accounts
and passwords and proper verb inheritance. See <A HREF="/player.html">Creating
A Player</A> for more information on what to do next.

</BLOCKQUOTE>

<A NAME="passwd"><B>passwd [local-player :&nbsp; <I>player</I>] to
[string : <I>newpass</I>]</B>

<BLOCKQUOTE>

Changes <I>player</I>'s password to <I>newpass</I>.

<P><TT>Example: If I type "passwd Bob to madhaxor", Bob's
password would be changed to "madhaxor".</TT></p>

</BLOCKQUOTE>

<A NAME="allow"><B>allow [local-player :&nbsp; <I>player</I>] to
[Verb-classname : <I>x</I>]</B>


<BLOCKQUOTE>

<p>Gives <I>player</I> the ability to use verb <I>x</I>. Note that
this becomes an innate ability of <I>player</I>. See also <A
HREF="enable">enable</A>.</p>

<P><TT>Example: If I type "allow Bob to divunal.common.author.swim",
Bob would gain the ability to use the swim verb, simply by typing
"swim" followed by swim's necessary arguements.</TT></p>

</BLOCKQUOTE>

<A NAME="disallow"><B>disallow [local-player : <I>player</I>] from
[verb-name : <I>verb</I>]</B>

<BLOCKQUOTE>

<p>Removes <I>player</I>'s ability to use <I>verb</I>.</p>

<P><TT>Example:
If I type "disallow Bob from swim", Bob will lose his ability to use
the swim verb, which would be a very cruel thing to do if he was in
deep water at the time.</TT>
</P>

</BLOCKQUOTE>

<A NAME="banish"><B>banish [local-thing : <I>thing</I>]</B>

<BLOCKQUOTE>

<p>Sets the location of <I>thing</I> to null. This effectively places
thing outside the map, where it cannot be reached by normal means.</p>

<P><TT>Example: if I type "banish Bob", bob will be placed
outside the map; He will still exist, but it will be impossible to walk
to or from his current location, and he will most likely be stuck there
unless he (or some other benefactor) has access to a teleportation power
of some kind.</TT></p>

</BLOCKQUOTE>

<A NAME="grab"><B>grab [global-thing : <I>thing</I>]</B>

<BLOCKQUOTE>

<p>Teleports <I>thing</I> to the user's current location. Remember to use
<I>thing</I>'s full global name.</p>

<P><TT>Example: If I type "grab ornate silver key", the ornate silver
key will disappear from the room where it currently is, and reappear
in the room where I currently am. If I just type "grab key", it will
attempt to bring me the object globally referred to as "key", which
almost certainly isn't what I want.</TT></p>

</BLOCKQUOTE>

<A NAME="toss"><B>toss [local-thing : <I>thing</I>] to [global-room : <I>room</I>]</B>

<BLOCKQUOTE>

<p>Teleports <I>thing</I> into the specified <i>room</i>.

<TT><P>
Example: If I wanted to put the ornate silver key back in the room where it was supposed to be (in this case, the Mausoleum Treasure Room), I would type "toss key to mausoleum treasure room". See how much easier life would be if you Referenced all your objects to common, easily typed synonyms? I would have hated to have had to type out the whole name "ornate silver key" every time I needed to do anything with it.
</P>
<P>Note that some combinations of <i>thing</i> and <i>room</i> will automatically fail, in the interest of preventing anything strange from happening (players becoming trapped, innappropriate or offensive topography, etc.)
</P></TT>

</BLOCKQUOTE>

<A NAME="barricade"><B>barricade [local-portal : <I>exit</I>]</B>

<BLOCKQUOTE>

<p>This removes <I>exit</I> from the room permanently.&nbsp; Note
that since all portals are actually one-way exits, this will not destroy
the reverse exit.</p>

<P><TT>Example: I'm in the Mansion Bedroom, a room with a north/south
hallway between it and the Mansion Bathroom.&nbsp; If I wanted to
block the passage to the bathroom, I would type "barricade
north". This would permanently remove the north exit of the Bedroom
that led to the Bathroom. However, the Bathroom would still have a
south exit leading to the Bedroom, which I should also probably get
rid of.</TT></p>

</BLOCKQUOTE>

<A NAME="dig"><B>dig [new-portal : <I>direction</I>] { to [new-room]
: <I>room</I>}</B>

<BLOCKQUOTE>

<p>Creates a new <I>room</I>, connected to your current location by
the portal <I>direction</I>. Remember that <I>room</I> must be a
unique name, and that there must not already be a a portal in the
specified <I>direction.  </I>See <A HREF="#draw">draw</A> for more
information on creating new things.</p>

<P><TT>Example: If I wanted to build a room to the north of the room
I'm currently in, I could type "dig north to West Wing Balcony".  A
new room called West Wing Balcony will be created, and a portal to it
will appear in the room I'm currently in, leading north. Dig always
creates two-way exits: the West Wing Balcony will have an exit leading
south back to the room I created it from.</TT></p>

</BLOCKQUOTE>

<A NAME="gate"><B>gate [new-portal : <I>direction</I>] to [global-room
: <I>room</I>]</B>

<BLOCKQUOTE>

<p>Opens a temporary one-way door in the <I>direction</I> specified,
leading to <I>room</I>.&nbsp; The gate lasts for about 30
seconds,&nbsp; and is visible to players as a swirling blue effect
similar to the twisted reality logo. Note that there must not already
be an exit in the <I>direction</I> that the gate is going to be
placed.</p>

<P><TT>Example: If I'm in a room that currently has no north exit, I
could type "gate north to West Wing Balcony", and create a temporary
exit that leads to the abovementioned room. Other players can see and
use the gate for as long as it lasts, but remember that gates are
one-way doors, and do not also create a way back to the room you
opened them from.</TT>

</BLOCKQUOTE>

<A NAME="handle"><B>handle [string : <I>event-title</I>] on [local-thing
: <I>target</I>] with [RealEventHandler-classname : <I>handler</I>]</B>

<BLOCKQUOTE>

<p>Loads <I>handler</I>, associates it with <I>event-title, </I>and
applies it to <I>target. </I>The end result of this process is that
<I>handler</I> will be executed whenever <I>event-title</I> is sent to
<I>target.</I></p>

<P><TT>Example: Say I wanted to make a button that, when pressed,
caused a door to open after a short delay. I would first <A
HREF="#draw">draw</A> the objects I need: we'll call them Dungeon
Automatic Door and Dungeon Door Button. Then, I would write a
DungeonButtonPush verb, and <A HREF="#enable">enable</A> it to the
button, so that players could push it to produce the desired
effect. The DungeonButtonPush verb would, when run, send a
handleDelayedEvent called "open door" to Dungeon Automatic Door, with
a 1 tick delay (30 seconds or so). I would then write a
DungeonDoorOpenHandler, which, when run, would cause the Dungeon
Automatic Door to open, and describe it opening to the occupants of
the room. Finally, I would apply the handle by typing "handle open
door on Dungeon Automatic Door with DungeonDoorOpenHandler". Then I
could put the door and the button in their intended places, <A
HREF="nail">nail</A> them, and use the door to <A
HREF="obstruct">obstruct</A> an exit so that it's being open or closed
actually matters to the players. Now, when a player presses the button
(or for that matter, when any other verb calls the open door event on
the door) the Dungeon Automatic Door will run its handler after a 30
second delay, and open.</TT></p>

</BLOCKQUOTE>


<P><B><A NAME="he">he [local-player :&nbsp; <I>player</I>]</B></P>
<P><A NAME="she"><B>she [local-player :&nbsp; <I>player</I>]</B></P>

<BLOCKQUOTE>

<p>Sets the gender of <I>player</I> to male or female,
respectively.  <P><TT>Example: Having recently created a new player
called Bob with <A HREF="#adduser">adduser</A>, I can make Bob be male
by typing "he Bob". Aside from the obvious roleplaying issues, making
Bob be male will also change the way the game refers to him, using
pronouns like "his" and "him". If I wanted to make Bob (or some more
appropriate character) female, I would simply type "she Bob".</TT>

</BLOCKQUOTE>

<A NAME="locate"><B>locate [global-thing : <I>thing</I>]</B>

<BLOCKQUOTE>

<p>Provides you with the current location of <I>thing</I>.</p>

<P><TT>Example: If I type "locate brass pocketwatch", I will be given
the location of the watch, which is normally something along the lines
of "Tenth is holding the brass pocketwatch" or "The brass pocketwatch
is in Tenths Workshop". And if I only recieved the name of the person
holding it, I could always locate that person as well for more
specific information.</TT></p>

</BLOCKQUOTE>

<A NAME="nail"><B>nail [local-thing : <I>object</I>]</B>

<BLOCKQUOTE>

Prevents <I>object</I> from being taken by players, and also from
appearing in the list of available objects in the room.
<P><TT>Example:&nbsp; Say I want to create a statue object, which can
be looked at by players, but not moved or listed in the listing of the
room's objects. I could <A HREF="#draw">draw</A> a new object called
"marble statue of Bacchus", <A HREF="#describe">describe</A> it in
whatever way I felt appropriate, and then nail it. I should also
mention the statue in the room's description, since otherwise the
players will have no way of knowing that it exists (it won't be listed
in the object window).&nbsp; However, players can still look at the
statue to see its description, and use any verbs that may have been <A
HREF="#enable">enable</A>d on it.</TT>

</BLOCKQUOTE>

<A NAME="yank"><B>yank [local-thing : <I>object</I>]</B>

<BLOCKQUOTE>

Removes the effects of the <A HREF="#nail">nail</A> verb on
<I>object</I>.

<P><TT>Example: If I changed my mind and decided that I want my statue
of Bacchus to be a normal object after all, I could simply type "yank
marble statue of Bacchus". The statue would reappear in the object
window, and players can once again pick it up and walk off with it
unless otherwise restrained.</TT></p>

</BLOCKQUOTE>

<A NAME="op"><B>op [local-location : <I>container</I>]</B><BR>
<A NAME="deop"><B>op [local-location : <I>container</I>]</B>

<BLOCKQUOTE>

Adds or Removes the Operable property on <I>object</I>, which governs
whether or not people can interact with the contents of the
object. (By "interact", we mean "just about anything more involved
than just looking at it.") By default, Locations are Operable.

<P><TT> Example: If I sketch myself a new Location called Blue Glass
Jar (as opposed to a regular generic Thing, like the kind created by
Draw, which cannot contain other objects), and I want to prevent
people from interacting with the contents, I would type "deop blue
glass jar". If I later decided that I wanted people to be able to play
with the stuff inside (because it's open at the top) I could type "op
blue glass jar".  </TT></p>

</BLOCKQUOTE>

<A NAME="broad"><B>broad [local-location : <I>container</I>]</B><BR>
<A NAME="debroad"><B>debroad [local-location : <I>container</I>]</B>

<BLOCKQUOTE>

Adds or Removes the Broadcast property on <I>object</I>, which governs
whether or not it's contents are openly listed when it appears in the
Object Window. <i>(Note that most Furniture should be Broadcast.)</i>
By default, Locations are not Broadcast.

<P><TT>
Example: If I want the contents of a location to be visible to the room, like things sitting on top of my Shoddy Wooden Table, I would type "broad shoddy wooden table". Then it and it's contents would appear in the Object Window as:
<BLOCKQUOTE>
A shoddy wooden table is here.<BR>
&nbsp&nbsp&nbsp&nbsp&nbsp; A dirty blue sock is on the shoody wooden table<BR>
&nbsp&nbsp&nbsp&nbsp&nbsp; A half empty carton of Kung Pao Chicken is on the shoddy wooden table<BR>
</BLOCKQUOTE>
I could reverse the process by typing "debroad shoddy wooden table", and the contents would no longer be listed below it in the Object Window.
</TT></p>

</BLOCKQUOTE>

<A NAME="vis"><B>vis [local-location : <I>container</I>]</B><BR>
<A NAME="devis"><B>devis [local-location : <I>container</I>]</B>

<BLOCKQUOTE>

Adds or Removes the Visible property on <I>object</I>, which governs
whether or not people can see or Look at the contents of the
object. Locations are Visible by default.

<P><TT>
Example: If I wanted to prevent people from looking at the contents of my Location, Black Box, I would type "devis black box". If I changed my mind later, I could always type "vis black box" to make the contents visible and look-at-able again.
</TT></p>

</BLOCKQUOTE>

<A NAME="obstruct"><B>obstruct [local-portal : <I>portal</I>] with
[local-thing : <I>door</I>]</B>

<BLOCKQUOTE>

<p>Obstructs <I>portal</I> with a <I>door</I> object. (There is a
class_door object in divunal which you can look at for more
information, and that you should <A HREF="#extend">extend</A> your doors
from) This causes movement through the portal to be governed by the
door object, which in turn can be opened, closed, locked, and so on.
Note that the Obstruct verb must be enabled on the object being
used as a door... You won't have much luck otherwise.</p>

<P><TT>Example: If I want to put a lockable door on the north exit to
my Mansion Master Bedroom, I would first <A HREF="#draw">draw</A> an
appropriately named door, and then type "obstruct north with Mansion
Master Bedroom Door". Passage through that exit, from either side,
will now be controlled by the door.&nbsp; The door, in turn, can be <A
HREF="#extend">extend</A>ed from class_door and/or configured in any
other way you wish, so that it can be openable, closeable, lockable,
etc. While the door remains in the room where you call the obstruct
verb, it is also listed as being in the connected room so that players
can interact with it from either side.</TT></p>

</BLOCKQUOTE>

<A NAME="persist"><B>persist [string : <I>mapname</I>]</B>

<BLOCKQUOTE>

Writes out a map file called <I>mapname</I>.por, containing
the current game state.

<P><TT>Example: This essentially "saves the game", recording the
current state of the world and everything in it. This ideally happens
before the pump server is shut down, but to be safe, it's usually a
good idea to persist the map yourself if you've just done a lot of
work and want to make sure it gets saved. If I've just added a whole
bunch of rooms and objects, I could type "persist tenthstuff" to save
a "tenthstuff.por" file. When the pump is restarted, the most recent
map file will be used; By persisting the map, you can make sure that
that the last save was <I>after</I> you finished all your hard work,
even if the pump isn't shut down properly.</TT></p>

</BLOCKQUOTE>


<A NAME="property"><B>property [string : <I>key</I>] to
[DynamicProperty-classname : <I>dproperty</I>]&nbsp; on [local-thing :
<I>thing</I>]</B>

<BLOCKQUOTE>

Assigns <I>key </I>to the dynamically loaded property
<I>dproperty</I>and attaches it to <I>thing</I>.

<P><TT>Example: This allows an extension of
twisted.reality.DynamicProperty to be loaded and attached to a
thing.&nbsp; I could <A HREF="#draw">draw</A> a Box of Many Donuts
object, and write a DynamicDonuts property that returns random types
of donuts. I could then bind this to my box by typing "property
DonutType to divunal.common.DynamicDonuts on Box Of Many
Donuts". Then, I could write a verb that allows players to get donuts
from the box...  This verb can get a random donut type from the
DonutType string, which in turn will be loaded by the DynamicDonuts
property. Admittedly, a box that produces random donuts has limited
applications, but hopefully you'll find a better use for dynamic
properties in your own work.</TT></p>

</BLOCKQUOTE>

<A NAME="reference"><B>reference [local-thing : <I>thing</I>] to [string
: <I>newname</I>]</B>

<BLOCKQUOTE>

Allows <I>thing</I> to be referred to as <I>newname</I> in addition to
it's global name.

<P><TT>Example: Given how relatively long and awkward a good global
name can be, it's good to give the players more convenient ways to
refer to your things. If you create an "ornate silver key", you should
probably also reference it to "silver key" and "key". This makes the
key much easier to work with, but remember that you must still refer
to it by it's full name when making a global arguement or calling it
from another room.</TT></p>

</BLOCKQUOTE>

<A NAME="scrutinize"><B>scrutinize [local-thing : <I>thing</I>]</B>

<BLOCKQUOTE>Displays the raw, text format code for <I>thing</I>.
<P><TT>Example: If I wanted to see the raw code of the magic box of
donuts I created in the <A HREF="#property">property</A> example, I
could type "scrutinize Box Of Many Donuts", and the code would pop up
in a separate window where I could scroll through it
easily.</TT></BLOCKQUOTE>

<A NAME="sketch"><B>sketch [new-thing : <I>thing</I>]</B>
<BLOCKQUOTE>

<p>Sketch allows the user to manually write the code for
<I>thing</I>.&nbsp; Remember that <I>thing </I>must not already
exist.</p>

<P><TT>Example: Sketch can be used to make complex or otherwise
unusual things, since the code can be entered manually and will not be
the product of normal thing-creating functions. Caution should be used
when working with raw code, as even minor carelessness could crash or otherwise
screw up whatever it is you are working with. You can learn more about
how to succesfully sketch things by reading .map files or using <A HREF="#scrutinize">scrutinize</A>
to view the code of existing things in the game.</TT></p>

</BLOCKQUOTE>


<A NAME="string"><B>string [string : <I>key</I>] to [string :
<I>value</I>] on [local-thing : <I>thing</I>]</B>
<br>
<B>string [string : <I>key</I>] on [local-thing : <I>thing</I>]</B>
<BLOCKQUOTE>

Set the string property <I>key</I> equal to <I>value</I>&nbsp;
and attaches it to <I>thing</I>.
<P><TT>Example: String is used to store textual information
inside of objects. If I were making a button that opened a number of different
doors, I could store the global name of the door that it will currently
open stored as a string. Then, I could display that string in the button's
description as a label, and make a dial that changed the string to the
name of a different door each time it was turned.</TT></P>
<P><B>NEW!</B> If you only specify <i>key</i> and <i>thing</i>, a response processor window will open, allowing you to edit <i>value</i> in a separate editing window.</P>
</BLOCKQUOTE>


<A NAME="theme"><B>theme [local-thing : <I>thing</I>] to [string :
<I>texture</I>]</B>

<BLOCKQUOTE>

<p>Sets the theme (background texture) of <I>thing</I> to
<I>texture</I>.</p>

<P><TT>Example: The theme is displayed as a background to the
description of a thing. This is normally used to change the background
texture of a room; I could type "theme here to wood" to give the room
I'm currently in a wood texture. However, I could also theme a player
or object, changing the background displayed behind their
description. Generally speaking, you should give major areas of the
game the same theme, so as to reduce the frequency with which the
theme has to change.</TT></p>

</BLOCKQUOTE>

<A NAME="thing"><B>thing [string : <I>key</I>] to [thing : <I>value</I>]
on [local-thing : <I>foo</I>]</B>

<BLOCKQUOTE>

Places a thing reference variable called <I>key</I> on <I>foo</I>, and
sets it equal to <I>value</I>.

<P><TT>Example: Thing, as a verb, is used to store references to other
things inside of a thing. Players all have an "oldlocation" thing
variable that stores the last room they were in, in case the pump is
restarted while a player is still between rooms. Thing could also be
used to store a reference to a player or object, such as the key
needed to unlock a particular door, or the last person to pass through
a certain portal.</TT></p>

</BLOCKQUOTE>

<A NAME="tunnel"><B>tunnel [new-portal : <I>direction</I>] to
[global-room : <I>room</I>]</B>

<BLOCKQUOTE>
<p>Creates a one-way exit <I>direction</I> between here and
<I>room</I>.</p>
<P>
<TT>Example: If I wanted to create a one way exit,
such as a hole leading to the basement of the mansion I'm in (a room
called Mansion Basement), I would type "tunnel down to Mansion
Basement". This would add a down exit to the room I'm currently in,
that leads to the basement.  However, the basement would not gain an
up exit back to here.</TT>
</p>
</BLOCKQUOTE>

<A NAME="int"><b>int [string : <i>property-name</i>] to [int : <i>value</i>] on [local-thing : <i>thing</i>]</b>
<BLOCKQUOTE>
      Sets the int property property-name on thing equal to value.
      If the property isn't already on thing, it gets added with
      the given value.

      Example: Int is used to store properties with integer values
      on objects. A simple example of it is "int Age to 20 on Bob",
      which would set the "Age" int property on Bob to 20. I could
      then check that property if I ever needed to know Bob's age.
</BLOCKQUOTE>

<A NAME="float"><b>float [string : <i>property-name</i>] to [float : <i>value</i>] on [local-thing : <i>thing</i>]</b>
<BLOCKQUOTE>
      Sets the float property property-name on thing equal to
      value. If the property isn't already on thing, it gets added
      with the given value.

      Example: Float is used to store properties with
      floating-point values on objects. If I wanted to have a
      furnace that gradually heated up, I could store its current
      temperature as a float value on it and update that poperty
      with a timed event.
</BLOCKQUOTE>

<A NAME="boolean"><b>boolean [string : <i>property-name</i>] to [<i>true</i> | <i>false</i>] on [local-thing : <i>thing</i>]</b>
<BLOCKQUOTE>
      Sets the boolean property property-name on thing equal to
      either true or false. If the property isn't already on thing,
      it gets added with the given value.

      Example: I create a lamp, and want a way to indicate whether
      or not it's lit. I can use this verb to add a boolean
      property "isLit" to the lamp, which will allow, e.g. other
      verbs to alter or check this value if they interact with
      light in some way.
</BLOCKQUOTE>

<A NAME="undescript"><b>undescript [string : <i>descriptor</i>] on [local-thing : <i>thing</i>]</b>
<BLOCKQUOTE>
      Removes the descriptive element descriptor from thing. (Such
      elements are shown with the label "descript" when
      scrutinizing something.)

      Example: This is particularly useful when testing in-game.
      Let's say I've changed how doors work so that they add a
      string called "openDesc" to the room's description when
      opened. I shortly realize that having multiple doors in the
      room won't work, as they'll all be overwriting the same
      string. I fix doors so that they preface the addition's label
      with their own names (e.g. "wooden door openDesc"). To get
      rid of the old "openDesc" that's still sitting on the room, I
      undescript it, and the room's description is updated
      immediately.
</BLOCKQUOTE>

<A NAME="cvs">
<b>cvs [(RealEventHandler-classname | Verb-class-classname) : <i>key</i>]</b><BR>
<b>cvs update</b><BR>
<BLOCKQUOTE>
If used on a RealEventHandler or Verb Class classname, this command will open the relevant code in an editor window, much like the ones used for changing Descriptions or String properties. You can make any changes to the code that you wish, and the results will be CVSed into the tree. Note that there's no way to debug it first; You can just change the code in CVS and then try to <A HREF="#compile">compile</A> it and see what happens. Still, it's better than nothing if you can't use CVS normally for some reason, or don't want to go through the trouble (and don't mind not being able to debug stuff very well.)
<P>
If called as "cvs update", it will cause the Pump to perform a CVS update, so that any code you have added and/or changed via "real" CVS will update into the game. You'll then be able to <A HREF="#compile">compile</A> your code... But remember to <A HREF="#refrump">refrump</A> so that your newly updated, recompiled code will actually be used in the game.</P>
</BLOCKQUOTE>

<A NAME="compile"><b>compile [(RealEventHandler-classname | Verb-class-classname) : <i>key</i>]</b>
<BLOCKQUOTE>
      Compiles key, a verb or event handler that's in your CVS
      tree. Note that this currently relies on many UNIX-isms and
      makes no pretense of being 100% pure Java or cross-platform in
      any way. Errors are now printed to your Faucet, but they're
      still hard to read, and debugging is annoying at best... You
      should really be editing and testing code on your own
      machine if at all possible.

      Rather than having to log out to add a verb or event handler,
      you can compile it using this command and then use
      <A HREF="#refrump">refrump</A> to load it in.
</BLOCKQUOTE>

<A NAME="refrump"><b>refrump</b>
<BLOCKQUOTE>
      Clears all the code caches. Use this to make a verb, event
      handler, dynamic property, or other dynamically loaded code
      that you have modified take effect.

      Example: Say I've just compiled a couple new verbs. Rather
      than restarting the server, I can simply use refrump to load
      all of the new code.
</BLOCKQUOTE>

<A NAME="killprop"><b>killprop [string : <i>property-name</i>] on [local-thing : <i>thing</i>]</b>
<BLOCKQUOTE>
      Removes the property property-name from thing.

      Another one that's great for testing. If you screw up when,
      say, adding properties to an object, you can easily remove
      them in-game.
</BLOCKQUOTE>

</BODY>
</HTML>
